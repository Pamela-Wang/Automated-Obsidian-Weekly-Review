/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
__export(exports, {
  default: () => ListModified
});
var import_obsidian = __toModule(require("obsidian"));
var DEFAULT_SETTINGS = {
  dailyNoteFormat: "",
  outputFormat: "- [[link]]",
  tags: ""
};
var ListModified = class extends import_obsidian.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.registerEvent(this.app.vault.on("modify", (file) => __async(this, null, function* () {
        const currentFile = file;
        const tags = this.settings.tags.replace(/\s/g, "").split(",");
        const dailyNoteFormat = this.settings.dailyNoteFormat;
        const dailyFile = this.app.vault.getAbstractFileByPath((0, import_obsidian.moment)().format(dailyNoteFormat) + ".md");
        const outputFormat = this.settings.outputFormat;
        const resolvedOutputFormat = outputFormat.replace("[[link]]", `[[${currentFile.basename}]]`);
        if (dailyFile === null) {
          new import_obsidian.Notice(`A daily file with format ${dailyNoteFormat} doesn't exist! Cannot append link`);
          return;
        }
        if (currentFile === dailyFile)
          return;
        if (this.fileIsLinked(dailyFile, currentFile.basename))
          return;
        if (tags[0] !== "" && !this.fileMeetsTagRequirements(currentFile, tags))
          return;
        yield this.app.vault.append(dailyFile, "\n" + resolvedOutputFormat);
      })));
      this.addSettingTab(new ListModifiedSettingTab(this.app, this));
    });
  }
  fileIsLinked(fileToCheck, link) {
    const cache = this.app.metadataCache.getFileCache(fileToCheck);
    return cache.links.some((l) => l.link === link);
  }
  fileMeetsTagRequirements(file, tags) {
    for (const tag of tags) {
      if (this.fileHasTag(file, tag))
        return false;
    }
    return true;
  }
  fileHasTag(file, tag) {
    const cache = this.app.metadataCache.getFileCache(file);
    return this.tagMetadataContainsTag(cache, tag) || this.frontmatterMetadataContainsTag(cache, tag);
  }
  tagMetadataContainsTag(cache, tagToMatch) {
    const tagCache = cache.tags;
    if (tagCache === void 0)
      return false;
    return tagCache.some((tag) => tag.tag === tagToMatch);
  }
  frontmatterMetadataContainsTag(cache, tagToMatch) {
    const frontmatterCache = cache.frontmatter;
    if (frontmatterCache === void 0)
      return false;
    return frontmatterCache.tags.some((tag) => tag === tagToMatch);
  }
  onunload() {
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
};
var ListModifiedSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Formatting" });
    new import_obsidian.Setting(containerEl).setName("Daily Note Format").setDesc("You can find this in your daily note settings menu. BE SURE TO include the folder path in square brackets if your daily notes do not reside in the root folder of your vault!").addText((text) => text.setPlaceholder("e.g. [Daily/]YYYY-MM-DD").setValue(this.plugin.settings.dailyNoteFormat).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.dailyNoteFormat = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Output Format").setDesc("The format to output added links. Use [[link]] as a placeholder to represent a link.").addText((text) => text.setPlaceholder("e.g. - [[link]]").setValue(this.plugin.settings.outputFormat).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.outputFormat = value;
      yield this.plugin.saveSettings();
    })));
    containerEl.createEl("h2", { text: "Criteria" });
    new import_obsidian.Setting(containerEl).setName("Blacklisted Tags").setDesc("Comma-separated list of tags. If a file has a tag present on this list, it won't be linked to! Leave this blank to disable this feature.").addText((text) => text.setPlaceholder("e.g. #daily, #\u{1F4A1}, #\u{1F527}").setValue(this.plugin.settings.tags).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.tags = value;
      yield this.plugin.saveSettings();
    })));
  }
};
